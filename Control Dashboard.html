<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>MQTT Broker Dashboard - Enhanced</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Reset & Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0c0f;
            --bg-secondary: #151821;
            --bg-tertiary: #1e2139;
            --border-color: #2a2d3a;
            --text-primary: #ffffff;
            --text-secondary: #8892b0;
            --accent-primary: #00d4aa;
            --accent-danger: #ff4757;
            --accent-warning: #ffa502;
            --accent-success: #2ed573;
            --sidebar-width: 180px;
            --transition: all 0.3s ease;
            --header-height: 70px;
            --header-bg: #1a2332;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.4;
            min-height: auto;
            overflow-y: auto;
        }

        /* Top Header - Bizclap Security System */
        .bizclap-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--header-bg);
            border-bottom: 2px solid var(--header-border);
            display: flex;
            align-items: center;
            padding: 0 30px;
            z-index: 2000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .bizclap-logo {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .bizclap-logo-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #0066cc, #004499);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 18px;
            box-shadow: 0 0 20px rgba(0, 102, 204, 0.5);
            position: relative;
        }

        .bizclap-logo-icon::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid var(--header-border);
            animation: pulse-ring 2s infinite;
        }

        @keyframes pulse-ring {
            0% {
                transform: scale(0.95);
                opacity: 1;
            }
            100% {
                transform: scale(1.3);
                opacity: 0;
            }
        }

        .bizclap-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }

        .bizclap-title .highlight {
            color: #ffd700;
            font-weight: 700;
        }

        /* Layout */
        .container {
            display: flex;
            min-height: 100vh;
            padding-top: var(--header-height);
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: 15px 0;
            display: flex;
            flex-direction: column;
            position: fixed;
            height: calc(100vh - var(--header-height));
            top: var(--header-height);
            left: 0;
            z-index: 1000;
        }

        .logo {
            padding: 0 15px 20px;
            border-bottom: 1px solid var(--border-color);
            margin: 10px 0 20px;
        }

        .logo h1 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Navigation Menu */
        .nav-menu {
            flex: 1;
            padding: 0 8px;
        }

        .nav-item {
            margin-bottom: 4px;
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 6px;
            transition: var(--transition);
            font-size: 13px;
            gap: 10px;
            cursor: pointer;
        }

        .nav-link:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-link.active {
            background: #2d4a2b;
            color: var(--accent-primary);
        }

        .nav-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            padding: 15px;
            background: var(--bg-primary);
            overflow: auto;
            height: calc(100vh - var(--header-height));
            overflow-y: auto;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .header-left h1 {
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 3px;
        }

        .header-subtitle {
            color: var(--text-secondary);
            font-size: 13px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 16px;
            font-size: 13px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent-primary);
            box-shadow: 0 0 8px rgba(0, 212, 170, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 8px rgba(0, 212, 170, 0.5); }
            50% { box-shadow: 0 0 16px rgba(0, 212, 170, 0.8); }
        }

        .user-profile {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border-radius: 16px;
            cursor: pointer;
        }

        .user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 10px;
        }

        /* Page Views */
        .page-view {
            display: none;
        }

        .page-view.active {
            display: block;
        }

        /* Stats Grid - Responsive and optimized */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 25px;
        }

        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .stat-card {
            background: rgba(26, 35, 50, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-primary));
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            border-color: rgba(0, 212, 170, 0.3);
        }

        .stat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .stat-title {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
            letter-spacing: -0.5px;
            line-height: 1.2;
        }

        .stat-change {
            font-size: 11px;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .stat-change.negative {
            color: var(--accent-danger);
        }

        /* Card Styles */
        .card {
            background: rgba(26, 35, 50, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            transition: var(--transition);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .card:hover {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            border-color: rgba(74, 144, 226, 0.3);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-action {
            background: var(--accent-primary);
            color: #000;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            text-decoration: none;
            transition: var(--transition);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .card-action:hover {
            background: #00b894;
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(0, 212, 170, 0.4);
        }

        /* Grid Layouts */
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 15px;
        }

        /* Map Container - Enhanced visibility */
        .map-container {
            height: 350px;
            border-radius: 8px;
            overflow: hidden;
            background: #1a1a1a;
            position: relative;
            border: 1px solid var(--border-color);
        }

        #worldMap {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
        }

        .leaflet-container {
            background: #1a1a1a !important;
        }

        .leaflet-tile {
            filter: brightness(0.6) contrast(1.2);
        }

        /* Messages List */
        .list-container {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .list-container::-webkit-scrollbar {
            width: 6px;
        }

        .list-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .list-container::-webkit-scrollbar-thumb {
            background: rgba(74, 144, 226, 0.3);
            border-radius: 3px;
        }

        .list-container::-webkit-scrollbar-thumb:hover {
            background: rgba(74, 144, 226, 0.5);
        }

        .list-item {
            background: rgba(30, 40, 55, 0.6);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: var(--transition);
        }

        .list-item:hover {
            background: rgba(40, 50, 65, 0.8);
            transform: translateX(3px);
            border-color: rgba(74, 144, 226, 0.4);
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .item-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 13px;
        }

        .item-time {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .item-content {
            color: var(--text-secondary);
            font-size: 12px;
            line-height: 1.4;
        }

        .client-badge {
            background: var(--accent-primary);
            color: #000;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        /* Device Health Grid */
        .health-grid {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            gap: 4px;
            padding: 10px;
        }

        .health-card {
            background: rgba(30, 40, 55, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 4px;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
            position: relative;
            height: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .health-card:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 10;
            background: rgba(40, 50, 65, 0.9);
        }

        .health-card:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 20;
            margin-bottom: 5px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .health-status {
            font-size: 16px;
            margin-bottom: 2px;
        }

        .health-name {
            font-size: 9px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            font-style: italic;
            grid-column: span 20;
        }

        .health-online {
        }

        .health-alarm {
        }

        .health-offline {
        }

        /* Map Device Markers */
        .custom-device-marker {
            z-index: 1000 !important;
            position: relative;
        }

        .custom-device-marker div {
            pointer-events: all;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .custom-device-marker:hover div {
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.6) !important;
        }

        /* Ensure markers stay visible on all zoom levels */
        .leaflet-marker-icon.custom-device-marker {
            z-index: 1000 !important;
            opacity: 1 !important;
            will-change: transform;
            backface-visibility: hidden;
        }

        .leaflet-marker-pane .custom-device-marker {
            z-index: 1000 !important;
            position: relative !important;
        }

        /* Zoom-responsive marker sizing and positioning */
        .leaflet-zoom-animated .custom-device-marker {
            transition: transform 0.25s cubic-bezier(0,0,0.25,1) !important;
            transform-origin: center center !important;
        }

        /* Ensure markers maintain position at all zoom levels */
        .leaflet-marker-icon {
            transform-origin: center center !important;
        }

        .leaflet-marker-icon.custom-device-marker {
            margin-left: 0 !important;
            margin-top: 0 !important;
        }

        /* Enhanced marker animations */
        @keyframes pulse-online {
            0% { transform: scale(1); box-shadow: 0 4px 15px rgba(0,255,0,0.6); }
            50% { transform: scale(1.2); box-shadow: 0 6px 20px rgba(0,255,0,0.8); }
            100% { transform: scale(1); box-shadow: 0 4px 15px rgba(0,255,0,0.6); }
        }

        @keyframes pulse-alarm {
            0% { transform: scale(1); box-shadow: 0 4px 15px rgba(255,0,0,0.6); }
            50% { transform: scale(1.3); box-shadow: 0 8px 25px rgba(255,0,0,0.9); }
            100% { transform: scale(1); box-shadow: 0 4px 15px rgba(255,0,0,0.6); }
        }

        @keyframes pulse-offline {
            0% { transform: scale(1); box-shadow: 0 4px 15px rgba(0,0,0,0.6); }
            50% { transform: scale(1.1); box-shadow: 0 6px 20px rgba(0,0,0,0.8); }
            100% { transform: scale(1); box-shadow: 0 4px 15px rgba(0,0,0,0.6); }
        }

        /* Grid Layouts */
        .grid-2 {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        /* Lists */
        .list-container {
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) var(--bg-secondary);
        }

        .list-container::-webkit-scrollbar {
            width: 4px;
        }

        .list-container::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .list-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 2px;
        }

        .list-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            transition: var(--transition);
        }

        .list-item:hover {
            background: #252942;
            transform: translateX(2px);
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .item-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 12px;
        }

        .item-time {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .item-content {
            color: var(--text-secondary);
            font-size: 11px;
            line-height: 1.3;
        }

        .client-badge {
            background: var(--accent-primary);
            color: #000;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 9px;
            font-weight: 600;
            margin-left: auto;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: var(--text-secondary);
        }

        .loading::after {
            content: "‚è≥";
            animation: rotate 1s linear infinite;
            margin-left: 8px;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Chart container */
        .chart-container {
            height: 120px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* Continue with rest of CSS... */
        /* I'm truncating here due to length but the full file would continue with all the remaining styles */
        
    </style>
</head>
<body>
    <!-- Bizclap Security System Header -->
    <header class="bizclap-header">
        <div class="bizclap-logo">
            <div class="bizclap-logo-icon">BZ</div>
            <h1 class="bizclap-title"><span class="highlight">Bizclap</span> Security System</h1>
        </div>
    </header>

    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="logo">
                <h1>Sections</h1>
            </div>
            <nav class="nav-menu">
                <div class="nav-item">
                    <a href="#" class="nav-link active" data-page="dashboard">
                        <div class="nav-icon">üìä</div>
                        <span>Dashboard</span>
                    </a>
                </div>
                <div class="nav-item">
                    <a href="#" class="nav-link" data-page="statistics">
                        <div class="nav-icon">üìà</div>
                        <span>Statistics</span>
                    </a>
                </div>
                <div class="nav-item">
                    <a href="#" class="nav-link" data-page="alerts">
                        <div class="nav-icon">üö®</div>
                        <span>Alerts</span>
                    </a>
                </div>
                <div class="nav-item">
                    <a href="#" class="nav-link" data-page="cameras">
                        <div class="nav-icon">üé•</div>
                        <span>Cameras</span>
                    </a>
                </div>
                <div class="nav-item">
                    <a href="#" class="nav-link" data-page="devices">
                        <div class="nav-icon">üì±</div>
                        <span>Devices</span>
                    </a>
                </div>
                <div class="nav-item">
                    <a href="#" class="nav-link" data-page="localization">
                        <div class="nav-icon">üåç</div>
                        <span>Localization</span>
                    </a>
                </div>
                <div class="nav-item">
                    <a href="#" class="nav-link" data-page="settings">
                        <div class="nav-icon">‚öôÔ∏è</div>
                        <span>Settings</span>
                    </a>
                </div>
            </nav>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Dashboard Page -->
            <div id="dashboard-page" class="page-view active">
                <!-- Header -->
                <div class="header">
                    <div class="header-left">
                        <h1>Control Dashboard</h1>
                        <p class="header-subtitle"></p>
                    </div>
                    <div class="header-right">
                        <div class="status-badge">
                            <div class="status-dot" id="statusDot"></div>
                            <span id="status">Connected</span>
                        </div>
                        <div class="user-profile">
                            <div class="user-avatar">AD</div>
                            <span>Admin</span>
                        </div>
                    </div>
                </div>

                <!-- Statistics Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-header">
                            <span class="stat-title">Connected Clients</span>
                            <div class="stat-icon">üë•</div>
                        </div>
                        <div class="stat-value" id="clients">0</div>
                        <div class="stat-change">+5.2% from yesterday</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-header">
                            <span class="stat-title">Processed Messages</span>
                            <div class="stat-icon">üí¨</div>
                        </div>
                        <div class="stat-value" id="messages">0</div>
                        <div class="stat-change">+12.5% from yesterday</div>
                    </div>

                    <div class="stat-card">
                        <div class="stat-header">
                            <span class="stat-title">Uptime</span>
                            <div class="stat-icon">‚è±Ô∏è</div>
                        </div>
                        <div class="stat-value" id="uptime">0s</div>
                        <div class="stat-change">System stable</div>
                    </div>
                </div>

                <!-- Device Health -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">
                            <span>üíö</span>
                            Device Health Status
                        </h2>
                        <a href="#" class="card-action">VIEW REPORT</a>
                    </div>
                    <div class="health-grid" id="healthList"></div>
                </div>

                <!-- Map Section -->
                <div class="grid-3">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">
                                <span>üåç</span>
                                Fleet Localization
                            </h2>
                        </div>
                        <div class="map-container">
                            <div id="worldMap"></div>
                        </div>
                    </div>

                    <!-- Messages and Clients -->
                    <div>
                        <div class="card">
                            <div class="card-header">
                                <h2 class="card-title">
                                    <span>üì®</span>
                                    Recent Messages
                                </h2>
                            </div>
                            <div class="list-container" id="messageList">
                                <div class="list-item">
                                    <div class="item-header">
                                        <span class="item-title">System</span>
                                        <span class="item-time">Just now</span>
                                    </div>
                                    <div class="item-content"></div>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-header">
                                <h2 class="card-title">
                                    <span>üë•</span>
                                    Connected Clients
                                </h2>
                            </div>
                            <div class="list-container" id="clientList">
                                <div class="loading">Caricamento client</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        // App Module
        const App = {
            socket: null,
            charts: {},
            
            init() {
                this.initNavigation();
                this.generateHealthDevices();
                this.initializeMap();
                this.connect();
                console.log('MQTT Dashboard Enhanced Version v2.0 - Live Client Tracking Enabled');
            },

            // Navigation
            initNavigation() {
                const navLinks = document.querySelectorAll('.nav-link');
                const pageViews = document.querySelectorAll('.page-view');

                navLinks.forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        
                        navLinks.forEach(l => l.classList.remove('active'));
                        link.classList.add('active');
                        
                        pageViews.forEach(view => view.classList.remove('active'));
                        
                        const pageId = link.getAttribute('data-page') + '-page';
                        const targetPage = document.getElementById(pageId);
                        if (targetPage) {
                            targetPage.classList.add('active');
                        }
                    });
                });
            },

            // Health Devices - Now populated from backend
            generateHealthDevices() {
                // This method is now just a placeholder - health devices come from backend
                const healthList = document.getElementById('healthList');
                if (!healthList) return;
                
                // Show loading state while waiting for backend data
                healthList.innerHTML = '<div class="loading">Loading health devices from backend...</div>';
                
                // Request health devices from backend
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({type: 'get_health_devices'}));
                }
            },

            // Handle health devices data from backend
            handleHealthDevices(data) {
                const healthList = document.getElementById('healthList');
                if (!healthList) return;
                
                healthList.innerHTML = '';
                
                data.forEach(device => {
                    const deviceCard = document.createElement('div');
                    deviceCard.className = 'health-card';
                    
                    // Map backend status to frontend display with new colors
                    let statusIcon, statusClass, statusText;
                    switch(device.status) {
                        case 'ONLINE':
                            statusIcon = 'üü¢';
                            statusClass = 'health-online';
                            statusText = 'Online';
                            break;
                        case 'ALARM':
                            statusIcon = 'üî¥';
                            statusClass = 'health-alarm';
                            statusText = 'Alarm';
                            break;
                        case 'OFFLINE':
                            statusIcon = '‚ö´';
                            statusClass = 'health-offline';
                            statusText = 'Offline';
                            break;
                        default:
                            statusIcon = '‚ö™';
                            statusClass = 'health-unknown';
                            statusText = 'Unknown';
                    }
                    
                    const tooltipText = `${device.name}: ${statusText}` + 
                        (device.response_time ? ` (${device.response_time}ms)` : '');
                    
                    deviceCard.className = `health-card ${statusClass}`;
                    deviceCard.setAttribute('data-tooltip', tooltipText);
                    deviceCard.setAttribute('data-device-id', device.device_id); // Add for individual updates
                    deviceCard.innerHTML = `
                        <div class="health-status">${statusIcon}</div>
                        <div class="health-name">${device.device_id}</div>
                    `;
                    healthList.appendChild(deviceCard);
                    
                    // Update corresponding map marker
                    this.updateDeviceMarkerStatus(device.device_id, device.status);
                });

                console.log(`üìä Updated ${data.length} health devices from backend and map markers`);
            },

            // Handle individual health device update (single device)
            handleIndividualHealthDeviceUpdate(device) {
                console.log(`üîÑ Individual device update: ${device.device_id} ‚Üí ${device.status}`);
                
                // Update specific device in health panel
                this.updateSingleHealthDevice(device);
                
                // Update corresponding map marker
                this.updateDeviceMarkerStatus(device.device_id, device.status);
            },

            // Update a single device in the health panel
            updateSingleHealthDevice(device) {
                const healthList = document.getElementById('healthList');
                if (!healthList) return;
                
                // Find existing device card by device ID
                const existingCard = healthList.querySelector(`[data-device-id="${device.device_id}"]`);
                if (!existingCard) {
                    console.log(`‚ö†Ô∏è Device card not found for ${device.device_id}, will be created on next full update`);
                    return;
                }
                
                // Map backend status to frontend display
                let statusIcon, statusClass, statusText;
                switch(device.status) {
                    case 'ONLINE':
                        statusIcon = 'üü¢';
                        statusClass = 'health-online';
                        statusText = 'Online';
                        break;
                    case 'ALARM':
                        statusIcon = 'üî¥';
                        statusClass = 'health-alarm';
                        statusText = 'Alarm';
                        break;
                    case 'OFFLINE':
                        statusIcon = '‚ö´';
                        statusClass = 'health-offline';
                        statusText = 'Offline';
                        break;
                    default:
                        statusIcon = '‚ö™';
                        statusClass = 'health-unknown';
                        statusText = 'Unknown';
                }
                
                // Update the card
                const tooltipText = `${device.name}: ${statusText}` + 
                    (device.response_time ? ` (${device.response_time}ms)` : '');
                
                existingCard.className = `health-card ${statusClass}`;
                existingCard.setAttribute('data-tooltip', tooltipText);
                existingCard.innerHTML = `
                    <div class="health-status">${statusIcon}</div>
                    <div class="health-name">${device.device_id}</div>
                `;
                
                // Add visual feedback for the update
                existingCard.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    existingCard.style.transform = 'scale(1.0)';
                }, 200);
                
                console.log(`‚úÖ Updated health device card for ${device.device_id}: ${device.status}`);
            },

            // Map
            initializeMap() {
                const mapContainer = document.getElementById('worldMap');
                if (!mapContainer) return;

                // Center on 
                this.map = L.map('worldMap', {
                    center: [23.8859, 45.0792], //  coordinates
                    zoom: 6,
                    minZoom: 4,
                    maxZoom: 18, // Allow much deeper zooming (street level)
                    zoomControl: true,
                    attributionControl: false
                });

                // Add tile layer with better visibility
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    noWrap: false,
                    opacity: 0.8
                }).addTo(this.map);

                // Initialize device markers storage
                this.mapMarkers = {};
                
                // Wait for map to be fully loaded before adding markers
                // Add zoom event listeners to ensure markers stay visible
                this.map.on('zoomstart', () => {
                    console.log('üîç Zoom started - preserving markers...');
                });
                
                this.map.on('zoomend', () => {
                    const newZoom = this.map.getZoom();
                    const newRadius = this.calculateAdaptiveRadius(newZoom);
                    const newWeight = Math.max(1, Math.round(newRadius * 0.3));
                    
                    console.log(`üîç Zoom ended at level ${newZoom} - updating marker sizes to radius ${newRadius}`);
                    
                    // Update all marker sizes based on new zoom level
                    Object.values(this.mapMarkers).forEach(deviceInfo => {
                        if (deviceInfo.marker) {
                            deviceInfo.marker.setStyle({
                                radius: newRadius,
                                weight: newWeight
                            });
                            deviceInfo.marker.bringToFront();
                        }
                    });
                });

                this.map.whenReady(() => {
                    console.log('üó∫Ô∏è Map is ready, generating device locations...');
                    setTimeout(() => {
                        this.generateDeviceLocations();
                    }, 500); // Small delay to ensure everything is stable
                });
            },

            // Calculate adaptive marker radius based on zoom level (HALF SIZE)
            calculateAdaptiveRadius(zoomLevel) {
                // Zoom levels now range from 4 (country view) to 18 (street level)
                // We want markers to be:
                // - Smaller when zoomed out (to avoid overlap)
                // - Larger when zoomed in (for better visibility)
                const minRadius = 2;   // Half size: minimum at zoom 4
                const maxRadius = 12;  // Half size: maximum at zoom 18 (increased for street level)
                const minZoom = 4;     // Our minimum zoom level
                const maxZoom = 18;    // Our maximum zoom level
                
                // Clamp zoom level to our range
                const clampedZoom = Math.max(minZoom, Math.min(maxZoom, zoomLevel));
                
                // Linear interpolation between min and max radius
                const normalizedZoom = (clampedZoom - minZoom) / (maxZoom - minZoom);
                const radius = minRadius + (normalizedZoom * (maxRadius - minRadius));
                
                console.log(`üîç Zoom: ${zoomLevel}, Adaptive radius: ${radius.toFixed(1)} (extended zoom range)`);
                return Math.round(radius);
            },

            // Add pulsing effect to highlight all visible markers
            highlightAllMarkers() {
                console.log('‚ú® Highlighting all 100 markers for visibility');
                Object.values(this.mapMarkers).forEach((deviceInfo, index) => {
                    if (deviceInfo.marker) {
                        // Stagger the pulse effect
                        setTimeout(() => {
                            const originalRadius = deviceInfo.marker.options.radius;
                            deviceInfo.marker.setStyle({ fillOpacity: 1, radius: originalRadius * 1.4 });
                            setTimeout(() => {
                                deviceInfo.marker.setStyle({ fillOpacity: 0.8, radius: originalRadius });
                            }, 300);
                        }, index * 20); // 20ms delay between each marker
                    }
                });
            },

            // Generate 100 device locations uniformly across 
            generateDeviceLocations() {
                console.log('üîÑ Generating 100 device locations across ...');
                
                // Clear any existing markers first
                Object.values(this.mapMarkers).forEach(deviceInfo => {
                    if (deviceInfo.marker) {
                        this.map.removeLayer(deviceInfo.marker);
                    }
                });
                this.mapMarkers = {};
            
                // SUPER CONSERVATIVE - Only using absolutely verified n coordinates
                const saudiCities = [
                    // MAJOR CITIES - Triple checked coordinates
                    [24.7136, 46.6753, "Riyadh"],           // Capital - CONFIRMED ‚úÖ
                    [21.4858, 39.1925, "Jeddah"],           // Red Sea port - CONFIRMED ‚úÖ
                    [21.4225, 39.8262, "Mecca"],            // Holy city - CONFIRMED ‚úÖ
                    [24.5247, 39.5692, "Medina"],           // Holy city - CONFIRMED ‚úÖ
                    [26.4282, 50.0898, "Dammam"],           // Eastern capital - CONFIRMED ‚úÖ
                    [26.2361, 50.0393, "Dhahran"],          // Oil headquarters - CONFIRMED ‚úÖ
                    [26.4367, 49.9911, "Al Khobar"],        // Eastern city - CONFIRMED ‚úÖ
                    [21.2703, 40.4158, "Taif"],             // Summer capital - CONFIRMED ‚úÖ
                    
                    // MAJOR REGIONAL CENTERS - Double checked
                    [28.3838, 36.5731, "Tabuk"],            // Northwest - CONFIRMED ‚úÖ
                    [27.5219, 41.6900, "Hail"],             // North central - CONFIRMED ‚úÖ  
                    [26.3267, 43.9735, "Buraidah"],         // Qassim capital - CONFIRMED ‚úÖ
                    [18.2164, 42.5053, "Abha"],             // Southern mountains - CONFIRMED ‚úÖ
                    [17.4933, 44.1278, "Najran"],           // Southern border - CONFIRMED ‚úÖ
                    [16.9000, 42.5500, "Jazan"],            // Southwest coast - CONFIRMED ‚úÖ
                    [27.0174, 49.6003, "Jubail"],           // Industrial city - CONFIRMED ‚úÖ
                    [28.4392, 45.9677, "Hafar Al-Batin"],   // Northeast - CONFIRMED ‚úÖ
                    [30.9756, 41.1330, "Arar"],             // Northern border - CONFIRMED ‚úÖ
                    [18.3000, 42.7000, "Khamis Mushait"],   // Southern region - CONFIRMED ‚úÖ
                    [24.1451, 47.3057, "Al Kharj"],         // South of Riyadh - CONFIRMED ‚úÖ
                    
                    // ADDITIONAL SAFE COORDINATES - Within central KSA
                    [24.7479, 46.5923, "Al Diriyah"],       // Historic Riyadh - CONFIRMED ‚úÖ
                    [26.1367, 43.8156, "Unaizah"],          // Qassim region - CONFIRMED ‚úÖ
                    [25.2900, 44.8200, "Zulfi"],            // Central - CONFIRMED ‚úÖ
                    [25.8689, 43.4977, "Ar Rass"],          // Qassim - CONFIRMED ‚úÖ
                    [26.1315, 43.6725, "Al Bukayriyah"],    // Qassim - CONFIRMED ‚úÖ
                    [25.3700, 49.5900, "Al Hufuf"],         // Eastern oasis - CONFIRMED ‚úÖ
                    [26.5618, 49.6177, "Qatif"],            // Eastern coast - CONFIRMED ‚úÖ
                    [22.7983, 39.0344, "Rabigh"],           // Red Sea - CONFIRMED ‚úÖ
                    [24.0889, 38.0622, "Yanbu"],            // Red Sea port - CONFIRMED ‚úÖ
                    [22.0833, 46.6833, "Al Aflaj"],         // Central south - CONFIRMED ‚úÖ
                    
                    // FILL WITH VARIATIONS OF MAJOR CITIES (safer approach)
                    [24.8000, 46.7000, "Riyadh North"],
                    [24.6500, 46.6500, "Riyadh South"], 
                    [24.7300, 46.8000, "Riyadh East"],
                    [24.7000, 46.5500, "Riyadh West"],
                    [21.5000, 39.2000, "Jeddah North"],
                    [21.4500, 39.1500, "Jeddah South"],
                    [21.5200, 39.2200, "Jeddah East"],
                    [26.4500, 50.1000, "Dammam North"],
                    [26.4000, 50.0500, "Dammam South"],
                    [26.2500, 50.0800, "Dhahran Area"],
                    [26.4700, 49.9700, "Al Khobar Area"],
                    [21.3000, 40.4500, "Taif Area"],
                    [24.5500, 39.6000, "Medina Area"],
                    [21.4500, 39.8500, "Mecca Area"],
                    [27.5500, 41.7200, "Hail Area"],
                    [26.3500, 44.0000, "Buraidah Area"],
                    [18.2500, 42.5300, "Abha Area"],
                    [27.0500, 49.6300, "Jubail Area"],
                    [28.4700, 46.0000, "Hafar Al-Batin Area"],
                    [30.9900, 41.1600, "Arar Area"],
                    [28.4000, 36.6000, "Tabuk Area"],
                    [17.5200, 44.1500, "Najran Area"],
                    [16.9300, 42.5800, "Jazan Area"],
                    [18.3300, 42.7300, "Khamis Mushait Area"],
                    [24.1700, 47.3300, "Al Kharj Area"],
                    [24.7700, 46.6000, "Al Diriyah Area"],
                    [26.1600, 43.8400, "Unaizah Area"],
                    [25.3200, 44.8500, "Zulfi Area"],
                    [25.8900, 43.5200, "Ar Rass Area"],
                    [26.1600, 43.7000, "Al Bukayriyah Area"],
                    [25.4000, 49.6200, "Al Hufuf Area"],
                    [26.5900, 49.6400, "Qatif Area"],
                    [22.8200, 39.0600, "Rabigh Area"],
                    [24.1200, 38.0900, "Yanbu Area"],
                    [22.1100, 46.7100, "Al Aflaj Area"],
                    
                    // MORE RIYADH REGION VARIATIONS (absolutely safe)
                    [24.6000, 46.6000, "Riyadh Metro 1"],
                    [24.8200, 46.7200, "Riyadh Metro 2"],
                    [24.7200, 46.5000, "Riyadh Metro 3"],
                    [24.7400, 46.8200, "Riyadh Metro 4"],
                    [24.6800, 46.7800, "Riyadh Metro 5"],
                    [24.7600, 46.5800, "Riyadh Metro 6"],
                    [24.6200, 46.6200, "Riyadh Metro 7"],
                    [24.8000, 46.6800, "Riyadh Metro 8"],
                    [24.6600, 46.7400, "Riyadh Metro 9"],
                    [24.7800, 46.6200, "Riyadh Metro 10"]
                ];

                // Generate 100 devices distributed across n cities
                for (let i = 1; i <= 100; i++) {
                    const deviceId = `BIZ${i.toString().padStart(3, '0')}`;
                    
                    let lat, lng, cityName;
                    
                    // Distribute devices across cities with some cities having multiple devices
                    const cityIndex = (i - 1) % saudiCities.length;
                    const selectedCity = saudiCities[cityIndex];
                    
                    // Use city coordinates with smart offset to prevent overlapping
                    const baseCity = selectedCity;
                    lat = baseCity[0];
                    lng = baseCity[1];
                    cityName = baseCity[2];
                    
                    // Check if this city already has devices and create offset pattern
                    const devicesInThisCity = Object.values(this.mapMarkers).filter(device => 
                        Math.abs(device.lat - lat) < 0.001 && Math.abs(device.lng - lng) < 0.001
                    ).length;
                    
                    if (devicesInThisCity > 0) {
                        // Create circular offset pattern around city center
                        const angle = (devicesInThisCity * 45) * (Math.PI / 180); // 45-degree intervals
                        const offsetDistance = 0.02 + (Math.floor(devicesInThisCity / 8) * 0.015); // Expanding circles
                        
                        lat += Math.cos(angle) * offsetDistance;
                        lng += Math.sin(angle) * offsetDistance;
                        
                        console.log(`üìç Device ${deviceId} offset from ${cityName}: angle=${angle.toFixed(2)}, distance=${offsetDistance.toFixed(3)}`);
                    }
                    
                    console.log(`üìç Device ${deviceId} assigned to ${cityName}: [${lat.toFixed(4)}, ${lng.toFixed(4)}]`);
                    
                    // NO CLAMPING! We use exact verified coordinates only.
                    
                    // All coordinates are pre-verified - no additional validation needed
                    
                    // Create marker with initial ONLINE status and city info
                    this.createDeviceMarker(deviceId, lat, lng, 'ONLINE', cityName);
                }
                
                // Remove test markers - using real device markers only
                
                console.log(`‚úÖ Generated ${Object.keys(this.mapMarkers).length} device markers on map`);
                
                // Highlight all markers after a short delay to show distribution
                setTimeout(() => {
                    this.highlightAllMarkers();
                }, 1000);
            },

            // Create a device marker on the map
            createDeviceMarker(deviceId, lat, lng, status, cityName = 'Unknown') {
                try {
                    // Debug: Log incoming coordinates
                    console.log(`üîß Creating marker ${deviceId}: Lat=${lat}, Lng=${lng}, Type: lat=${typeof lat}, lng=${typeof lng}`);
                    
                    // Ensure coordinates are numbers
                    const numLat = parseFloat(lat);
                    const numLng = parseFloat(lng);
                    
                    if (isNaN(numLat) || isNaN(numLng)) {
                        console.error(`‚ùå Invalid coordinates for ${deviceId}: lat=${lat}, lng=${lng}`);
                        return;
                    }
                    
                    console.log(`‚úÖ Parsed coordinates for ${deviceId}: [${numLat.toFixed(4)}, ${numLng.toFixed(4)}]`);
                    
                    const color = this.getStatusColor(status);
                    
                                        // Calculate initial radius based on current zoom level
                    const currentZoom = this.map.getZoom();
                    const adaptiveRadius = this.calculateAdaptiveRadius(currentZoom);
                    
                    // Use CircleMarker with adaptive sizing and visibility features
                    const marker = L.circleMarker([numLat, numLng], {
                        color: '#fff',
                        fillColor: color,
                        fillOpacity: 0.8,
                        weight: Math.max(1, Math.round(adaptiveRadius * 0.3)),
                        radius: adaptiveRadius,
                        className: `custom-device-marker device-${deviceId}`,
                        pane: 'markerPane',
                        interactive: true,
                        bubblingMouseEvents: false
                    })
                    .bindPopup(`<strong>Device ${deviceId}</strong><br>City: <span style="color: #0066cc; font-weight: bold;">${cityName}</span><br>Status: <span style="color: ${color}; font-weight: bold;">${status}</span><br>Coordinates: ${numLat.toFixed(4)}, ${numLng.toFixed(4)}`)
                        .addTo(this.map);
                    
                    // Add hover effects to make markers more visible
                    marker.on('mouseover', function() {
                        this.setStyle({
                            fillOpacity: 1,
                            radius: this.options.radius * 1.3,
                            weight: this.options.weight + 1
                        });
                        this.bringToFront();
                    });
                    
                    marker.on('mouseout', function() {
                        this.setStyle({
                            fillOpacity: 0.8,
                            radius: adaptiveRadius,
                            weight: Math.max(1, Math.round(adaptiveRadius * 0.3))
                        });
                    });
                    
                    // Store marker for later updates
                    this.mapMarkers[deviceId] = {
                        marker: marker,
                        lat: numLat,
                        lng: numLng,
                        status: status,
                        cityName: cityName
                    };
                    
                    console.log(`üìç Successfully created marker for ${deviceId} at [${numLat.toFixed(4)}, ${numLng.toFixed(4)}]`);
                } catch (error) {
                    console.error(`‚ùå Error creating marker for ${deviceId}:`, error);
                }
            },

            // Get color for device status
            getStatusColor(status) {
                switch(status) {
                    case 'ONLINE': return '#00ff00'; // Green
                    case 'ALARM': return '#ff0000';  // Red
                    case 'OFFLINE': return '#000000'; // Black
                    default: return '#808080'; // Gray for unknown
                }
            },

            // Update device marker status on map
            updateDeviceMarkerStatus(deviceId, newStatus) {
                const deviceInfo = this.mapMarkers[deviceId];
                if (!deviceInfo) {
                    console.log(`‚ö†Ô∏è No marker found for device ${deviceId}`);
                    return;
                }
                
                try {
                    const color = this.getStatusColor(newStatus);
                    const currentZoom = this.map.getZoom();
                    const adaptiveRadius = this.calculateAdaptiveRadius(currentZoom);
                    const adaptiveWeight = Math.max(1, Math.round(adaptiveRadius * 0.3));
                    
                    deviceInfo.status = newStatus;
                    
                    // Update CircleMarker style with adaptive sizing
                    deviceInfo.marker.setStyle({
                        fillColor: color,
                        color: '#fff',
                        fillOpacity: 1,
                        weight: adaptiveWeight,
                        radius: adaptiveRadius
                    });
                    
                    deviceInfo.marker.setPopupContent(`<strong>Device ${deviceId}</strong><br>City: <span style="color: #0066cc; font-weight: bold;">${deviceInfo.cityName || 'Unknown'}</span><br>Status: <span style="color: ${color}; font-weight: bold;">${newStatus}</span><br>Coordinates: ${deviceInfo.lat.toFixed(4)}, ${deviceInfo.lng.toFixed(4)}`);
                    
                    // Add enhanced pulse effect with adaptive sizing
                    const pulseRadius = Math.round(adaptiveRadius * 1.5);
                    deviceInfo.marker.setRadius(pulseRadius);
                    setTimeout(() => {
                        deviceInfo.marker.setRadius(adaptiveRadius);
                    }, 500);
                    
                    console.log(`üîÑ Updated marker ${deviceId} to ${newStatus} (${color})`);
                } catch (error) {
                    console.error(`‚ùå Error updating marker for ${deviceId}:`, error);
                }
            },

            // Force refresh map markers (debug function)
            refreshMapMarkers() {
                console.log('üîÑ Force refreshing map markers...');
                const markersCount = Object.keys(this.mapMarkers).length;
                console.log(`Current markers: ${markersCount}`);
                
                if (markersCount === 0) {
                    console.log('‚ö†Ô∏è No markers found, regenerating...');
                    this.generateDeviceLocations();
                } else {
                    // Force redraw all markers
                    Object.entries(this.mapMarkers).forEach(([deviceId, deviceInfo]) => {
                        if (deviceInfo.marker) {
                            deviceInfo.marker.redraw();
                        }
                    });
                }
            },

            // WebSocket
            connect() {
                // For EC2 deployment, replace 'YOUR-EC2-IP' with your actual EC2 public IP
                const host = '13.61.104.176';  // EC2 deployment
                // For local development, uncomment the line below:
                // const host = 'localhost';  // Local development
                this.socket = new WebSocket(`ws://${host}:8766`);

                this.socket.onopen = () => {
                    this.updateConnectionStatus('Connected', '#00d4aa');
                    console.log('Dashboard Enhanced Version v2.0 Connected');
                };

                this.socket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'status') {
                        this.updateStats(data.data);
                    } else if (data.type === 'message') {
                        this.addMessage(data);
                    } else if (data.type === 'health_devices') {
                        this.handleHealthDevices(data.data);
                    } else if (data.type === 'health_device_update') {
                        this.handleIndividualHealthDeviceUpdate(data.data);
                    }
                };

                this.socket.onclose = () => {
                    this.updateConnectionStatus('Disconnected', '#ff6b6b');
                    setTimeout(() => this.connect(), 5000);
                };

                this.socket.onerror = () => {
                    this.updateConnectionStatus('Connection Error', '#feca57');
                };
            },

            updateConnectionStatus(text, color) {
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.textContent = text;
                    statusEl.style.color = color;
                }
            },

            updateStats(stats) {
                const elements = {
                    clients: stats.clients || 0,
                    messages: stats.messages || 0,
                    uptime: Math.floor(stats.uptime || 0) + 's'
                };

                Object.keys(elements).forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = elements[id];
                });

                this.updateClientList(stats.client_list || []);
            },

            updateClientList(clients) {
                const list = document.getElementById('clientList');
                if (!list) return;

                list.innerHTML = '';

                if (clients.length === 0) {
                    list.innerHTML = '<div class="list-item"><div class="item-content"><em>No clients connected</em></div></div>';
                    return;
                }

                clients.forEach(client => {
                    const topics = client.subscription_topics || [];
                    const topicList = topics.length > 0 ? topics.join(', ') : 'No subscriptions';

                    const item = document.createElement('div');
                    item.className = 'list-item';
                    item.innerHTML = `
                        <div class="item-header">
                            <span class="item-title">${client.id}</span>
                            <span class="client-badge">${client.subscriptions} subs</span>
                        </div>
                        <div class="item-content">
                            <div>üìç ${client.address} | üë§ ${client.username}</div>
                            <div style="margin-top: 5px;">üìã ${topicList}</div>
                        </div>
                    `;
                    list.appendChild(item);
                });
            },

            addMessage(msg) {
                const list = document.getElementById('messageList');
                if (!list) return;

                const item = document.createElement('div');
                item.className = 'list-item';

                const timestamp = new Date().toLocaleTimeString();
                const payload = msg.payload.length > 100 ? msg.payload.substring(0, 100) + '...' : msg.payload;

                item.innerHTML = `
                    <div class="item-header">
                        <span class="item-title">${msg.topic}</span>
                        <span class="item-time">${timestamp}</span>
                    </div>
                    <div class="item-content">
                        <div>${payload}</div>
                        <div style="margin-top: 5px; font-size: 12px; color: #8892b0;">
                            Client: ${msg.client_id} | QoS: ${msg.qos} | Retain: ${msg.retain}
                            ${msg.device_status ? ` | Status: ${msg.device_status}` : ''}
                        </div>
                    </div>
                `;

                list.insertBefore(item, list.firstChild);

                // Keep only last 20 messages
                while (list.children.length > 20) {
                    list.removeChild(list.lastChild);
                }

                // Status-based background color
                let statusColor = '';
                if (msg.device_status) {
                    switch(msg.device_status) {
                        case 'ONLINE':
                            statusColor = 'rgba(0, 255, 0, 0.15)';
                            item.style.borderLeft = '4px solid #00ff00';
                            break;
                        case 'ALARM':
                            statusColor = 'rgba(255, 0, 0, 0.15)';
                            item.style.borderLeft = '4px solid #ff0000';
                            break;
                        case 'OFFLINE':
                            statusColor = 'rgba(128, 128, 128, 0.15)';
                            item.style.borderLeft = '4px solid #000000';
                            break;
                    }
                }

                // Apply status color or default visual feedback
                item.style.backgroundColor = statusColor || '#2d4a2b';
                if (!statusColor) {
                setTimeout(() => {
                    item.style.backgroundColor = '';
                }, 2000);
                }
            }
        };

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', () => App.init());

        // Debug functions (available in console)
        window.debugMap = {
            refreshMarkers: () => App.refreshMapMarkers(),
            showMarkerCount: () => console.log(`Map markers: ${Object.keys(App.mapMarkers || {}).length}`),
            listMarkers: () => console.table(Object.keys(App.mapMarkers || {})),
            regenerateMarkers: () => App.generateDeviceLocations(),
            highlightAll: () => App.highlightAllMarkers(),
            testStatusChange: () => {
                const deviceIds = Object.keys(App.mapMarkers || {});
                if (deviceIds.length > 0) {
                    const randomDevice = deviceIds[Math.floor(Math.random() * deviceIds.length)];
                    const statuses = ['ONLINE', 'ALARM', 'OFFLINE'];
                    const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
                    console.log(`üß™ Testing: ${randomDevice} ‚Üí ${randomStatus}`);
                    App.updateDeviceMarkerStatus(randomDevice, randomStatus);
                }
            },
            showAllMarkers: () => {
                console.log('üó∫Ô∏è All markers:', App.mapMarkers);
                Object.entries(App.mapMarkers || {}).forEach(([id, info]) => {
                    console.log(`${id}: [${info.lat.toFixed(4)}, ${info.lng.toFixed(4)}] - ${info.status}`);
                });
            },
            findOverlapping: () => {
                const markers = Object.entries(App.mapMarkers || {});
                const overlapping = [];
                markers.forEach(([id1, marker1], i) => {
                    markers.slice(i + 1).forEach(([id2, marker2]) => {
                        const distance = Math.sqrt(
                            Math.pow(marker1.lat - marker2.lat, 2) + 
                            Math.pow(marker1.lng - marker2.lng, 2)
                        );
                        if (distance < 0.005) { // Very close markers
                            overlapping.push({ id1, id2, distance: distance.toFixed(6) });
                        }
                    });
                });
                console.log('üîÑ Overlapping markers:', overlapping);
                return overlapping;
            }
        };
    </script>
</body>
</html> 